package itmo.lab5.server;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import itmo.lab5.shared.models.Coordinates;
import itmo.lab5.shared.models.Flat;
import itmo.lab5.shared.models.House;
import itmo.lab5.shared.models.enums.Furnish;
import itmo.lab5.shared.models.enums.Transport;
import itmo.lab5.shared.models.enums.View;

public class DatabaseManager {
    private static final Map<String, DatabaseManager> instances = new HashMap<>();
    private final Connection connection;
    private final ReentrantLock lock = new ReentrantLock();
    private final String schema;

    private DatabaseManager(String url, String user, String password, String schema) throws SQLException {
        this.connection = DriverManager.getConnection(url, user, password);
        this.schema = schema;
        
        try (Statement stmt = connection.createStatement()) {
            // Attempt to set schema, ignore if already set or not supported
            stmt.execute("SET SCHEMA '" + schema + "'");
        } catch (SQLException e) {
             // Log or handle the exception if setting schema fails, but don't stop execution.
             // For example, if the schema is already set or user doesn't have permission to SET SCHEMA.
             System.err.println("Warning: Could not set schema to '" + schema + "': " + e.getMessage());
        }
    }

    public static synchronized DatabaseManager getInstance(String url, String user, String password, String schema) throws SQLException {
        return instances.computeIfAbsent(schema, 
            k -> {
                try {
                    return new DatabaseManager(url, user, password, schema);
                } catch (SQLException e) {
                    throw new RuntimeException("Failed to create DatabaseManager for schema " + schema, e);
                }
            });
    }

    private String table(String tableName) {
        return  schema + "." + tableName;
    }
    /**
     * Retrieves the user ID by username.
     * @param username The username to look up.
     * @return The user ID, or null if not found.
     * @throws SQLException If a database error occurs.
     */
    private Integer getUserIdByName(String username) throws SQLException {
        String sql = "SELECT id FROM " + table("users") + " WHERE name = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, username);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt("id");
                }
            }
        }
        return null;
    }

    /**
     * Retrieves the username by user ID.
     * @param userId The user ID to look up.
     * @return The username, or null if not found.
     * @throws SQLException If a database error occurs.
     */
    private String getUsernameById(int userId) throws SQLException {
        String sql = "SELECT name FROM " + table("users") + " WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString("name");
                }
            }
        }
        return null;
    }

    /**
     * Inserts a Flat object and its associated Coordinates and House objects into the database.
     * The flat's ID is auto-generated by the database.
     *
     * @param flat The Flat object to insert. Its ID will be ignored and set by the DB.
     * @param ownerName The username of the owner of this flat.
     * @return The auto-generated ID of the inserted flat, or -1 if insertion fails.
     * @throws SQLException If a database error occurs.
     */
    public int insertFlat(Flat flat, String ownerName) throws SQLException {
        lock.lock();
        try {
            connection.setAutoCommit(false); // Start transaction

            Integer ownerId = getUserIdByName(ownerName);
            if (ownerId == null)
                throw new SQLException("Owner user '" + ownerName + "' not found.");

            int coordinatesId = insertCoordinates(flat.getCoordinates());
            Integer houseId = flat.getHouse() != null ? insertHouse(flat.getHouse()) : null; // Use Integer for nullability

            String sql = "INSERT INTO " + table("Flats") + " (name, coordinates_id, creation_date, area, number_of_rooms, " +
                         "furnish, view, transport, house_id, owner_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";

            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, flat.getName());
                stmt.setInt(2, coordinatesId);
                stmt.setDate(3, Date.valueOf(flat.getCreationDate()));
                stmt.setDouble(4, flat.getArea()); // DECIMAL handles DOUBLE PRECISION from Java fine
                stmt.setInt(5, flat.getNumberOfRooms());
                stmt.setObject(6, flat.getFurnish().name(), Types.OTHER); // Use .name() for ENUMs
                stmt.setObject(7, flat.getView() != null ? flat.getView().name() : null, Types.OTHER); // Use .name() for ENUMs
                stmt.setObject(8, flat.getTransport().name(), Types.OTHER); // Use .name() for ENUMs
                stmt.setObject(9, houseId, Types.INTEGER); // Use setObject for nullable Integer
                stmt.setInt(10, ownerId);

                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    int generatedId = rs.getInt("id");
                    connection.commit();
                    return generatedId; // Возвращаем ID вместо -1
                } else {
                    connection.rollback(); // Rollback if no ID returned
                    return -1;
                }
            }

        } catch (SQLException e) {
            connection.rollback();
            throw e;
        } finally {
            connection.setAutoCommit(true); 
            lock.unlock();
        }
    }

    private int insertCoordinates(Coordinates coordinates) throws SQLException {
        String sql = "INSERT INTO " + table("Coordinates") + " (x, y) VALUES (?, ?) RETURNING id";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setLong(1, coordinates.getX());
            stmt.setDouble(2, coordinates.getY());
            ResultSet rs = stmt.executeQuery();
            if (rs.next())
                return rs.getInt("id");
        }
        return -1;
    }

    private Integer insertHouse(House house) throws SQLException {
        if (house == null) return null;

        String sql = "INSERT INTO " + table("Houses") + " (name, year, number_of_floors) VALUES (?, ?, ?) RETURNING id";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, house.getName());
            stmt.setInt(2, house.getYear());
            stmt.setLong(3, house.getNumberOfFloors());
            ResultSet rs = stmt.executeQuery();
            if (rs.next())
                return rs.getInt("id");
        }
        return null;
    }

    /**
     * Updates an existing Flat object in the database, including its associated
     * Coordinates and House. Only updates if the specified ownerName owns the flat.
     *
     * @param id The ID of the flat to update.
     * @param flat The Flat object containing the new values.
     * @param ownerName The username of the owner.
     * @return true if the flat was updated, false otherwise (e.g., not found or not owned).
     * @throws SQLException If a database error occurs.
     */
    public boolean updateFlat(int id, Flat flat, String ownerName) throws SQLException {
        lock.lock();
        try {
            connection.setAutoCommit(false);

            Integer ownerId = getUserIdByName(ownerName);
            if (ownerId == null) {
                connection.rollback();
                return false; // User not found
            }

            // Check if the flat exists and belongs to the ownerName (using owner_id)
            if (!checkFlatOwnership(id, ownerId)) {
                connection.rollback();
                return false; 
            }

            // Fetch current flat details to get existing coordinates_id and house_id
            String getFlatDetailsSql = "SELECT coordinates_id, house_id FROM " + table("Flats") + " WHERE id = ?";
            int currentCoordsId;
            Integer currentHouseId = null;

            try (PreparedStatement stmt = connection.prepareStatement(getFlatDetailsSql)) {
                stmt.setInt(1, id);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    currentCoordsId = rs.getInt("coordinates_id");
                    currentHouseId = rs.getObject("house_id", Integer.class);
                } else {
                    connection.rollback();
                    return false; // Flat not found (should be caught by checkFlatOwnership, but defensive)
                }
            }

            // Update Coordinates (coordinates_id is NOT NULL, so it always exists)
            if (flat.getCoordinates() != null) {
                updateCoordinates(currentCoordsId, flat.getCoordinates());
            }

            // Update or (re-)insert House
            Integer newHouseId = currentHouseId; // Assume it stays the same unless changed
            if (flat.getHouse() != null) {
                if (currentHouseId != null) {
                    // Update existing house
                    updateHouse(currentHouseId, flat.getHouse());
                } else {
                    // Insert new house and link it
                    newHouseId = insertHouse(flat.getHouse());
                }
            } else { // If newFlat.getHouse() is null, it means we want to set house_id to null
                newHouseId = null;
            }

            String sql = "UPDATE " + table("Flats") + " SET name = ?, creation_date = ?, area = ?, number_of_rooms = ?, " +
                         "furnish = ?, view = ?, transport = ?, house_id = ? WHERE id = ? AND owner_id = ?";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, flat.getName());
                stmt.setDate(2, Date.valueOf(flat.getCreationDate()));
                stmt.setDouble(3, flat.getArea());
                stmt.setInt(4, flat.getNumberOfRooms());
                stmt.setObject(5, flat.getFurnish().name(), Types.OTHER);
                stmt.setObject(6, flat.getView() != null ? flat.getView().name() : null, Types.OTHER);
                stmt.setObject(7, flat.getTransport().name(), Types.OTHER);
                stmt.setObject(8, newHouseId, Types.INTEGER); // Set newHouseId (can be null)
                stmt.setInt(9, id);
                stmt.setInt(10, ownerId); 

                int rowsAffected = stmt.executeUpdate();
                if (rowsAffected > 0) {
                    connection.commit();
                    return stmt.executeUpdate() > 0;
                } else {
                    connection.rollback();
                    return false;
                }
            }

        } catch (SQLException e) {
            connection.rollback();
            throw e;
        } finally {
            connection.setAutoCommit(true);
            lock.unlock();
        }
    }

    private boolean updateCoordinates(int id, Coordinates coordinates) throws SQLException {
        // Only update non-null fields in coordinates
        String sql = "UPDATE " + table("Coordinates") + " SET x = COALESCE(?, x), y = COALESCE(?, y) WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            // Using COALESCE to update only if new value is not null, otherwise keep old value
            if (coordinates.getX() != null) stmt.setLong(1, coordinates.getX()); else stmt.setNull(1, Types.BIGINT);
            if (coordinates.getY() != null) stmt.setDouble(2, coordinates.getY()); else stmt.setNull(2, Types.DOUBLE);
            stmt.setInt(3, id);
            return stmt.executeUpdate() > 0;
        }
    }

    private boolean updateHouse(int id, House house) throws SQLException {
        // Only update non-null fields in house
        String sql = "UPDATE " + table("Houses") + " SET name = COALESCE(?, name), year = COALESCE(?, year), number_of_floors = COALESCE(?, number_of_floors) WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            if (house.getName() != null) stmt.setString(1, house.getName()); else stmt.setNull(1, Types.VARCHAR);
            if (house.getYear() != null) stmt.setInt(2, house.getYear()); else stmt.setNull(2, Types.INTEGER);
            if (house.getNumberOfFloors() != null) stmt.setLong(3, house.getNumberOfFloors()); else stmt.setNull(3, Types.BIGINT);
            stmt.setInt(4, id);
            return stmt.executeUpdate() > 0;
        }
    }

    public HashMap<Integer, Flat> getAllFlats() throws SQLException {
        lock.lock();
        try {
            HashMap<Integer, Flat> flatsMap = new HashMap<>();
            String sql = "SELECT f.*, c.x, c.y, h.name AS house_name, h.year AS house_year, h.number_of_floors AS house_floors, u.name AS owner_username " +
                         "FROM " + table("Flats") + " f " +
                         "JOIN " + table("Coordinates") + " c ON f.coordinates_id = c.id " +
                         "LEFT JOIN " + table("Houses") + " h ON f.house_id = h.id " +
                         "JOIN " + table("users") + " u ON f.owner_id = u.id";

            try (Statement stmt = connection.createStatement();
                ResultSet rs = stmt.executeQuery(sql)) {

                while (rs.next()) {
                    Flat flat = new Flat();
                    int id = rs.getInt("id");
                    flat.setId(id);
                    flat.setName(rs.getString("name")); // Correctly sets the flat's name
                    
                    // Coordinates
                    flat.setCoordinates(new Coordinates(rs.getLong("x"), rs.getDouble("y")));
                    
                    flat.setCreationDate(LocalDate.parse(rs.getDate("creation_date").toString()));
                    flat.setArea(rs.getDouble("area")); // DECIMAL handles DOUBLE PRECISION from Java fine
                    flat.setNumberOfRooms(rs.getInt("number_of_rooms"));
                    flat.setFurnish(Furnish.valueOf(rs.getString("furnish")));
                    String viewStr = rs.getString("view");
                    flat.setView(viewStr != null ? View.valueOf(viewStr) : null);
                    flat.setTransport(Transport.valueOf(rs.getString("transport")));

                    // House
                    String houseName = rs.getString("house_name");
                    if (houseName != null) {
                        House house = new House(
                            houseName,
                            rs.getInt("house_year"),
                            rs.getLong("house_floors")
                        );
                        flat.setHouse(house);
                    } else {
                        flat.setHouse(null);
                    }
                    
                    // FIX: This line was incorrect. It should set ownerName, not overwrite flat.name.
                    flat.setOwnerName(rs.getString("owner_username")); // Correctly sets the owner's username

                    flatsMap.put(id, flat);
                }
            }
            return flatsMap;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Removes a flat from the database. Only removes if the specified ownerName owns the flat.
     *
     * @param id The ID of the flat to remove.
     * @param ownerName The username attempting to remove the flat.
     * @return true if the flat was removed, false otherwise (e.g., not found or not owned).
     * @throws SQLException If a database error occurs.
     */
    public boolean removeFlat(int id, String ownerName) throws SQLException {
        lock.lock();
        try {
            Integer ownerId = getUserIdByName(ownerName);
            if (ownerId == null)
                return false;

            // ON DELETE CASCADE on coordinates_id handles coordinate deletion.
            // ON DELETE SET NULL on house_id handles house association.
            String sql = "DELETE FROM " + table("Flats") + " WHERE id = ? AND owner_id = ?";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setInt(1, id);
                stmt.setInt(2, ownerId);
                return stmt.executeUpdate() > 0;
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Clears all flats belonging to a specific owner from the database.
     *
     * @param ownerName The username whose flats should be cleared.
     * @return true if successful, false otherwise.
     * @throws SQLException If a database error occurs.
     */
    public boolean clearFlatsByOwner(String ownerName) throws SQLException {
        lock.lock();
        try {
            Integer ownerId = getUserIdByName(ownerName);
            if (ownerId == null) {
                return false; // User not found
            }

            // ON DELETE CASCADE on coordinates_id handles coordinate deletion.
            String sql = "DELETE FROM " + table("Flats") + " WHERE owner_id = ?";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setInt(1, ownerId);
                stmt.executeUpdate(); 
                return true;
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks if a flat with the given ID is owned by the specified user ID.
     * @param flatId The ID of the flat to check.
     * @param ownerId The user ID to check ownership against.
     * @return true if the flat exists and is owned by the user, false otherwise.
     * @throws SQLException If a database error occurs.
     */
    public boolean checkFlatOwnership(int flatId, int ownerId) throws SQLException {
        String sql = "SELECT COUNT(*) FROM " + table("Flats") + " WHERE id = ? AND owner_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, flatId);
            stmt.setInt(2, ownerId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1) > 0;
                }
            }
        }
        return false;
    }

    private boolean usernameExists(String username) throws SQLException {
        String sql = "SELECT COUNT(*) FROM " + table("users") + " WHERE name = ?";
        
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, username);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1) > 0;
                }
            }
        }
        return false;
    }

    /**
     * Adds a new user to the database.
     * @param username The username.
     * @param password The raw password (will be hashed).
     * @return true if user was added, false if username already exists.
     * @throws SQLException If a database error occurs.
     */
    public boolean addUser(String username, String password) throws SQLException {
        lock.lock();
        try {
            if (usernameExists(username)) {
                return false; // User already exists
            }

            String salt = generateDeterministicSalt(username);
            String hashedPassword = hashPasswordWithSalt(password, salt);
            // Column name is 'password' in the DDL, so use that.
            String sql = "INSERT INTO " + table("users") + " (name, password) VALUES (?, ?)"; 
            
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, username);
                stmt.setString(2, hashedPassword);
                
                int rowsAffected = stmt.executeUpdate();
                return rowsAffected > 0;
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks if a user exists and the provided password matches the stored hash.
     * @param username The username.
     * @param password The raw password to check.
     * @return true if user exists and password matches, false otherwise.
     * @throws SQLException If a database error occurs.
     */
    public boolean userExists(String username, String password) throws SQLException {
        String storedHash = getPasswordHash(username);
        if (storedHash == null) {
            return false; // User does not exist
        }
        
        String salt = generateDeterministicSalt(username);
        String hashedInputPassword = hashPasswordWithSalt(password, salt);
        
        return storedHash.equals(hashedInputPassword);
    }

    private String getPasswordHash(String username) throws SQLException {
        // Column name is 'password' in the DDL.
        String sql = "SELECT password FROM " + table("users") + " WHERE name = ?"; 
        
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, username);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString("password");
                }
            }
        }
        return null;
    }

    // MD5 hashing methods (unchanged)
    private String generateDeterministicSalt(String username) {
        String prefix = username.length() > 0 ? 
            username.substring(0, Math.min(4, username.length())) : "";
        
        String reversed = new StringBuilder(prefix).reverse().toString();
        return reversed + username.length() + username.hashCode();
    }

    private String hashPasswordWithSalt(String password, String salt) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            String combined = salt.substring(0, Math.min(2, salt.length())) + 
                            password + 
                            salt.substring(Math.min(2, salt.length()));
            
            byte[] hash = md.digest(combined.getBytes(StandardCharsets.UTF_8));
            
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("MD5 algorithm not found", e);
        }
    }

    public void close() throws SQLException {
        connection.close();
        instances.remove(schema);
    }
}
